"""
Singleton entity that tracks numbers and stats
"""
type EntityStats @entity {
  "ID is set to 1"
  id: ID!
  "Number of indexers"
  indexerCount: Int!
  "Number of delegators"
  delegatorCount: Int!
  "Number of curators"
  curatorCount: Int!
  "Most recent Era processed for Indexer badges"
  lastEraProcessed: BigInt!
}

type Winner @entity {
  "ETH address of the winner"
  id: ID!
  "Number of badges awarded to address"
  badgesAwarded: Int!
  "All of the badge awards"
  badgeAwards: [BadgeAward!]! @derivedFrom(field: "winner")
}

"""
The badge that is awarded to winner
"""
type BadgeAward @entity {
  id: ID!
  "Address of the winner"
  winner: Winner!
  "Block number or era in which badge was awarded"
  awardedAt: AwardedAt!
  "Additional details about the badge"
  definition: BadgeDefinition!
  "Number in which the badge was awarded"
  badgeNumber: Int!
  "Properties for streak type badges"
  streakProperties: BadgeStreakProperties
}

"Additional details related to the badge"
type BadgeDefinition @entity {
  "Name of the badge"
  id: ID!
  "Description of the badge"
  description: String!
  "IFTP link to the NFT badge"
  image: String!
  "Name of the artist responsible for NFT badge"
  artist: String!
  "Optional link to the artist's portfolio"
  artistWebsite: String
  "Voting power for governance voting"
  votingPower: BigInt!
  "Total count of badges"
  badgeCount: Int!
  "URL slug for the frontend"
  urlHandle: String!
  "Associated protocol for the badge"
  protocol: Protocol!
  "All of the badge awards with this definition"
  badgeAwards: [BadgeAward!]! @derivedFrom(field: "definition")
}

type BadgeStreakProperties @entity {
  id: ID!
  badgeAward: BadgeAward!
  "Useful for calculating delegation streak length"
  streakStartBlockNumber: BigInt!
}

"Every BadgeAward was awarded at a block or era"
type AwardedAt @entity {
  id: ID!
  "Type (block, era, etc.) of value property"
  type: AwardedAtType!
  "Number representing a point in time the badge was awarded"
  value: BigInt!
  "Badge that was awarded"
  badgeAward: BadgeAward!
}

"BadgeAwards are created on a per block or per era basis"
enum AwardedAtType {
  Block
  Era
}

type Protocol @entity {
  "Name of the protocol"
  id: ID!
  "URL slug for the frontend"
  urlHandle: String!
  "Description for the protocol"
  description: String!
  "Website for the protocol"
  website: String!
}

"""
Created when any indexer is instantiated to track order of indexers
"""
type IndexerCount @entity {
  "Numeric count of Indexer used during for loops"
  id: ID!
  "Associated indexer"
  indexer: Indexer!
}

"""
Created when any delegator is instantiated to track order of delegators
"""
type DelegatorCount @entity {
  "Numeric count of Delegator used during for loops"
  id: ID!
  "Associated delegator"
  delegator: Delegator!
}

"""
Metadata for the Indexer along with parameters and staking data
"""
type Indexer @entity {
  "Address of Indexer"
  id: ID!
  "Percentage of eras indexer has earned badge"
  twentyEightEpochsLaterBadgePercentage: BigDecimal!
  "Number of eras indexer failed to earn badge"
  ineligibleTwentyEightEpochsLaterBadgeCount: Int!
  "Number of times indexer failed to earn badge"
  isClosingAllocationLateCount: Int!
}

"""
Metadata for the Delegator
"""
type Delegator @entity {
  "Address of Delegator"
  id: ID!
  "Number of delegations with unique indexers"
  uniqueDelegationCount: Int!
  "Number of active delegations with unique indexers"
  uniqueActiveDelegationCount: Int!
  "Block number when most recent delegation streak was started"
  streakStartBlockNumber: BigInt!
}

"""
Metadata for the Curator
"""
type Curator @entity {
  "Address of Curator"
  id: ID!
  "Number of different subgraphs Curator has signalled"
  uniqueSignalCount: Int!
}

"""
Addresses that have been awarded badges that come with voting power
"""
type Voter @entity {
  "Address of protocol worker"
  id: ID!
  "Cumulative voting power across all badges"
  votingPower: BigInt!
}

"""
Metadata for the Delegator
"""
type DelegatedStake @entity {
  "Delegator + Indexer"
  id: ID!
  delegator: Delegator!
  indexer: Indexer!
  shares: BigInt!
}

"""
Metadata for the Curator
"""
type SignalledStake @entity {
  "{Curator}-{SubgraphId}"
  id: ID!
  curator: Curator!
  subgraphId: String!
  signal: BigInt!
  tokenBalance: BigInt!
}

"""
Joins Indexer metrics over a particular era
"""
type IndexerEra @entity {
  id: ID! # {indexer}-{era}
  indexer: Indexer!
  era: BigInt!
  isClosingAllocationLate: Boolean!
  isSlashed: Boolean!
}

"""
A state channel Allocation representing a single Indexer-SubgraphDeployment stake
"""
type Allocation @entity {
  "Channel Address"
  id: ID!
  "Epoch this allocation was created"
  createdAtEpoch: BigInt!
  "Epoch this allocation was closed in"
  closedAtEpoch: BigInt
  "Indexer that created this Allocation"
  indexer: Indexer!
  "SubgraphDeploymentID of this Allocation"
  subgraphDeploymentID: ID!
}

enum AllocationStatus {
  Null # == indexer == address(0)
  Active # == not Null && tokens > 0 #
  Closed # == Active && closedAtEpoch != 0. Still can collect, while you are waiting to be finalized. a.k.a settling
  Finalized # == Closing && closedAtEpoch + channelDisputeEpochs > now(). Note, the subgraph has no way to return this value. it is implied
  Claimed # == not Null && tokens == 0 - i.e. finalized, and all tokens withdrawn
}
