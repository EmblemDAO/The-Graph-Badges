########################
## The Graph Entities ##
########################

"""
Singleton entity that tracks numbers and stats
"""
type EntityStats @entity {
  "ID is set to 1"
  id: ID!
  "Number of indexers"
  indexerCount: Int!
  "Number of delegators"
  delegatorCount: Int!
  "Number of curators"
  curatorCount: Int!
  "Number of publishers"
  publisherCount: Int!
  "Number of TokenLockWallets"
  tokenLockWalletCount: Int!
  "Number of badges earned"
  earnedBadgeCount: Int!
  "Number of unique BadgeWinners"
  badgeWinnerCount: Int!
}

type GraphAccount @entity {
  "ETH address of Graph Account"
  id: ID!
  "BadgeWinner associated with this Graph Account"
  badgeUser: BadgeUser!
  "Number of Graph badges awarded to this account"
  awardCount: Int!
  "Indexer fields for this Graph Account. Null if never indexed"
  indexer: Indexer @derivedFrom(field: "account")
  "Delegator fields for this Graph Account. Null if never delegated"
  delegator: Delegator @derivedFrom(field: "account")
  "Curator fields for this Graph Account. Null if never curated"
  curator: Curator @derivedFrom(field: "account")
  "Developer fields for this Graph Account. Null if never published subgraphs"
  publisher: Publisher @derivedFrom(field: "account")
  "Token Lock Wallet for this Graph Account. Null if no token lock wallet"
  tokenLockWallets: [TokenLockWallet!] @derivedFrom(field: "beneficiary")
}

type TokenLockWallet @entity {
  "Contract address"
  id: ID!
  "Beneficiary of this TokenLockWallet"
  beneficiary: GraphAccount!
}

"""
Metadata for the Indexer along with parameters and staking data
"""
type Indexer @entity {
  "Address of Indexer"
  id: ID!
  "Graph Account associated with this indexer"
  account: GraphAccount!
  "Number of different subgraphs this indexer has allocated on"
  uniqueSubgraphAllocationCount: Int!
  "Number of currently open allocations"
  uniqueOpenAllocationCount: Int!
  "Cumulative number of Allocations closed by this indexer"
  allocationsClosedOnTime: Int!
  "CURRENT tokens delegated to the indexer"
  delegatedTokens: BigInt!
  "The total amount of indexing rewards given to delegators"
  delegatorIndexingRewards: BigInt!
  "The percent of indexing rewards generated by the total stake that the Indexer keeps for itself. In parts per million"
  indexingRewardCut: Int!
  "Total query fees collected. Includes the portion given to delegators"
  queryFeesCollected: BigInt!
  "Allocations created by this indexer"
  allocations: [Allocation!]! @derivedFrom(field: "indexer")
}

"""
A state channel Allocation representing a single Indexer-Subgraph stake
"""
type Allocation @entity {
  "Channel Address"
  id: ID!
  "Epoch this allocation was created"
  createdAtEpoch: BigInt!
  "Epoch this allocation was closed in"
  closedAtEpoch: BigInt
  "Indexer that created this allocation"
  indexer: Indexer!
  "Subgraph Deployment for this allocation"
  subgraph: SubgraphDeployment!
}

"""
Tracks which subgraphs an indexer has opened allocations on
"""
type SubgraphAllocation @entity {
  "{indexer}-{subgraphDeploymentId}"
  id: ID!
  "indexer indexing the subgraph"
  indexer: Indexer!
  "subgraph being indexed"
  subgraph: Subgraph!
}

"""
Metadata for the Delegator
"""
type Delegator @entity {
  "Address of Delegator"
  id: ID!
  "Graph Account associated with this delegator"
  account: GraphAccount!
  "Number of active delegations with at least 10k GRT"
  uniqueActiveDelegationCount: Int!
}

"""
Metadata for the Delegator
"""
type DelegatedStake @entity {
  "Delegator + Indexer"
  id: ID!
  "Delegator or this stake"
  delegator: Delegator!
  "Indexer that was delegated to"
  indexer: Indexer!
  "cumulative tokens delegated (does not account for undelegating)"
  tokens: BigInt!
  "true if tokens has ever been >= 100"
  crossed100: Boolean!
}

"""
Metadata for the Curator
"""
type Curator @entity {
  "Address of Curator"
  id: ID!
  "Graph Account associated with this curator"
  account: GraphAccount!
  "Number of different subgraphs Curator has signalled (cumulative)"
  uniqueSignalCount: Int!
}

"""
Metadata for the Curator
"""
type NameSignal @entity {
  "{Curator}-{SubgraphId}"
  id: ID!
  "Curator who signalled"
  curator: Curator!
  "Subgraph that was signalled on"
  subgraphId: Subgraph!
  "CUMULATIVE number of tokens the curator has signalled"
  signalledTokens: BigInt!
  "CUMULATIVE number of tokens the curator has unsignalled"
  unsignalledTokens: BigInt!
  "Shares of the name pool (GNS) that the curator has from signaling their GRT"
  nameSignal: BigInt!
  "Actual signal shares that the name pool minted with the GRT provided by the curator"
  signal: BigDecimal!
  "Curator average cost basis for this name signal on this subgraph"
  nameSignalAverageCostBasis: BigDecimal! # note this is ONLY name signal. This is okay for the protocol for now
  "nameSignalAverageCostBasis / nameSignal"
  nameSignalAverageCostBasisPerSignal: BigDecimal!
  "Curator average cost basis for the version signal on this subgraph name pool"
  signalAverageCostBasis: BigDecimal!
  "signalAverageCostBasis / signal"
  signalAverageCostBasisPerSignal: BigDecimal!
}

type Publisher @entity {
  "ETH address of Publisher Account"
  id: ID!
  "Graph Account associated with this publisher"
  account: GraphAccount!
  "Subgraphs published by this account"
  subgraphs: [Subgraph!]! @derivedFrom(field: "owner")
  "Number of Subgraphs this Publisher has deployed"
  subgraphCount: Int!
}

type Subgraph @entity {
  "{publisher}-{subgraph number}"
  id: ID!
  "Graph Account that published this subgraph"
  owner: Publisher!
  "First indexer to close an allocation on this subgraph"
  firstToOpen: Indexer
  "block which this subgraph was published (ignores versioning)"
  blockPublished: BigInt!
  "NameSignals associated with this Subgraph"
  nameSignals: [NameSignal!]! @derivedFrom(field: "subgraphId")
  "Subgraph metadata"
  metadataHash: Bytes!
  "Current version. Null if the subgraph is deprecated"
  currentVersion: SubgraphVersion
  "List of all the subgraph versions included the current one"
  versions: [SubgraphVersion!]! @derivedFrom(field: "subgraph")
  "Version counter"
  versionCount: BigInt!
}

"""
The SubgraphVersion entity represents a version of the Subgraph. A new SubgraphVersion is created
whenever there is an update to the Subgraph triggered by the owner. The new SubgraphVersion can
then point to a new SubgraphDeployment, thus allowing the Subgraph to resolve to a different
deployment, while keeping the same endpoint. The metadata and label are stored on IPFS. The label
is for the developer to provide a semantic version. This is different from the version, which is
just a counter than increases each time a new SubgraphVersion is created for a Subgraph.
"""
type SubgraphVersion @entity {
  "Concatenation of subgraph, subgraph deployment, and version ID"
  id: ID!
  "Subgraph of this version"
  subgraph: Subgraph!
  "Subgraph deployment of this version"
  subgraphDeployment: SubgraphDeployment!
  "Version number"
  version: BigInt!
  "Subgraph version metadata content address"
  metadataHash: Bytes!
}

"""
The SubgraphDeployment is represented by the immutable subgraph code that is uploaded, and posted
to IPFS. A SubgraphDeployment has a manifest which gives the instructions to the Graph Network on
what to index. The entity stores relevant data for the SubgraphDeployment on how much it is being
staked on and signaled on in the contracts, as well as how it is performing in query fees. It is
related to a SubgraphVersion.
"""
type SubgraphDeployment @entity {
  "Subgraph Deployment ID. The IPFS hash with Qm removed to fit into 32 bytes"
  id: ID!
  "Block when the subgraph was created"
  blockPublished: BigInt!
  "The versions this subgraph deployment relates to"
  versions: [SubgraphVersion!]! @derivedFrom(field: "subgraphDeployment")
}

"""
Protocols indexed by this subgraph
"""
type Protocol @entity {
  "Name of the protocol"
  id: ID!
}

########################
#### Badge Entities ####
########################

"""
Ethereum accounts this subgraph is tracking in order to award badges
"""
type BadgeUser @entity {
  "Ethereum address"
  id: ID!
  "Graph Account associated with this user"
  graphAccount: GraphAccount! @derivedFrom(field: "badgeUser")
  "BadgeWinner null if no badges won"
  badgeWinner: BadgeWinner @derivedFrom(field: "badgeUser")
  "Progress user has made along predefined metrics"
  progress: [Progress!]! @derivedFrom(field: "badgeUser")
}

"""
BadgeUsers that have earned at least one badge
"""
type BadgeWinner @entity {
  "ETH address of the BadgeWinner"
  id: ID!
  "Associated BadgeUser"
  badgeUser: BadgeUser!
  "Number of badge awards won"
  earnedBadgeCount: Int!
  "Number of badge awards minted"
  mintedAwardCount: Int!
  "Voting power accumulated from all badges"
  votingPower: BigInt!
  "Badges awarded to address"
  earnedBadges: [EarnedBadge!]! @derivedFrom(field: "badgeWinner")
}

"""
EarnedBadges are awarded to BadgeWinners for satisfying BadgeDefinition thresholds
"""
type EarnedBadge @entity {
  "{badgeName}-{BadgeWinner}"
  id: ID!
  "Address of the BadgeWinner"
  badgeWinner: BadgeWinner!
  "Block number in which badge was awarded"
  blockAwarded: BigInt!
  "Timestamp in which badge was awarded"
  timestampAwarded: BigInt!
  "Hash of the transaction that triggered this award"
  transactionHash: String!
  "Additional details about the badge"
  definition: BadgeDefinition!
  "Ordered number in which the badge was awarded for the associated definition"
  awardNumber: Int!
  "Ordered number in which the badge was awarded across all badges"
  globalAwardNumber: Int!
  "Data specific to this earnedBadges of a given BadgeDefinition"
  metadata: [EarnedBadgeMetadata!]! @derivedFrom(field: "earnedBadge")
}

"""
These metrics can be referenced by a BadgeDefinitionFactory smart contract
"""
enum BadgeMetric {
  INDEXER_SUBGRAPHS_INDEXED
  INDEXER_QUERY_FEES_COLLECTED
  INDEXER_ALLOCATIONS_OPENED
  INDEXER_DELEGATOR_COUNT
  DELEGATOR_INDEXERS
  CURATOR_SUBGRAPHS_SIGNALLED
  CURATOR_HOUSE_ODDS
  "incremented when a curator is the first to signal on their own subgraph"
  CURATOR_APE
  "incremented with a curator curates on another badgeWinner's subgraph within 100 blocks"
  PUBLISHER_SIGNAL_ATTRACTED
  "the amount of GRT signalled on a given Publisher's Subgraphs"
  PUBLISHER_SUBGRAPHS_DEPLOYED
  USER_BADGES_WON
}

"""
BadgeDefinitions are created by the BadgeDefinitionManager smart contract.
Subgraphs may also have genesis BadgeDefinitions that are baked in for retroactive
drops.
"""
type BadgeDefinition @entity {
  "Name of badge"
  id: ID!
  "Description of badge"
  description: String!
  "Name of metric being tracked"
  metric: BadgeMetric!
  "Value that metric must reach in order for a badge to be awarded"
  threshold: BigInt!
  "The level of the badge in the badge track, from 0 to N"
  level: Int
  "Voting power acrued when badge is awarded"
  votingPower: BigInt!
  "Total count of earned badges"
  earnedBadgeCount: Int!
  "IPFS URI containing metadata about this BadgeDefinition"
  ipfsURI: String!
  "Badges awarded with this definition"
  earnedBadges: [EarnedBadge!]! @derivedFrom(field: "definition")
}

################################
#### Internal Badge Entities ###
################################

"""
Saves progress along a metric for an account
"""
type Progress @entity {
  "{Account address}-{BadgeMetric}"
  id: ID!
  "Account who has made this progress"
  badgeUser: BadgeUser!
  "BadgeMetric being tracked"
  metric: BadgeMetric!
  "Current value of metric. Negative progress is not supported. value can only go up"
  value: BigInt!
}

"""
BadgeMetric -> BadgeDefinitions tracking that metric
"""
type MetricConsumer @entity {
  "BadgeMetric"
  id: ID!
  "BadgeDefinitions using this metric"
  badgeDefinitions: [BadgeDefinition!]!
}

################################
# These are only required by Emblem frontend
################################

enum EarnedBadgeMetadataName {
  INDEXER
  DELEGATOR
  CURATOR
  DEVELOPER
  SUBGRAPH
  SUBGRAPH_DEPLOYMENT
  TOKENS
}

"""
EarnedBadge metadata specific to the given BadgeDefinition
"""
type EarnedBadgeMetadata @entity {
  "{EarnedBadge}-{metricName}"
  id: ID!
  "Name of metric"
  name: EarnedBadgeMetadataName!
  "Value"
  value: String!
  "EarnedBadge the metadata refers to"
  earnedBadge: EarnedBadge!
}
