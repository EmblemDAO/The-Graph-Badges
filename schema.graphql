# type StandardBadgeProps @entity {
#   id: ID!
#   awardedAtBlock: BigInt
# }

"""
Singleton entity that tracks number of other entities/badges
"""
type EntityStats @entity {
  "ID is set to 1"
  id: ID!
  "Number of indexers"
  indexerCount: Int!
  "Number of FirstToCloseBadge"
  firstToCloseBadgeCount: Int!
  "Number of twentyEightDaysLaterBadge"
  twentyEightDaysLaterBadgeCount: Int!
}

"""
Metadata for the Indexer along with parameters and staking data
"""
type Indexer @entity {
  id: ID! # SubgraphDeploymentId
  "Epoch which the last twentyEightEpochsLater badge starts"
  twentyEightEpochsLaterStartStreak: BigInt!
}

"""
Awarded to indexers who are first to close an allocation for a subgraph
"""
type FirstToCloseBadge @entity {
  id: ID! # SubgraphDeploymentId
  # badge: StandardBadgeProps!
  indexer: Bytes!
  awardedAtBlock: BigInt!
}

"""
Awarded to indexers who close their allocations every 28 epochs or fewer
"""
type TwentyEightEpochsLaterBadge @entity {
  id: ID! # SubgraphDeploymentId
  indexer: Indexer!
  epochStartStreak: BigInt!
  epochStreakLength: BigInt!
  epochEndStreak: BigInt
}

# type SlashedBadge @entity {
#   id: ID!   # <indexrAddress>-<SlashedBadgeNumber>

# }

"""
A state channel Allocation representing a single Indexer-SubgraphDeployment stake
"""
type Allocation @entity {
  "Channel Address"
  id: ID!
  "Epoch this allocation was created"
  createdAtEpoch: BigInt!
  "Epoch this allocation was closed in"
  closedAtEpoch: BigInt
}

enum AllocationStatus {
  Null # == indexer == address(0)
  Active # == not Null && tokens > 0 #
  Closed # == Active && closedAtEpoch != 0. Still can collect, while you are waiting to be finalized. a.k.a settling
  Finalized # == Closing && closedAtEpoch + channelDisputeEpochs > now(). Note, the subgraph has no way to return this value. it is implied
  Claimed # == not Null && tokens == 0 - i.e. finalized, and all tokens withdrawn
}
