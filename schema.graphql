########################
## The Graph Entities ##
########################

"""
Singleton entity that tracks numbers and stats relating to The Graph
"""
type TheGraphEntityStats @entity {
  "ID is set to 1"
  id: ID!
  "Number of indexers"
  indexerCount: Int!
  "Number of delegators"
  delegatorCount: Int!
  "Number of curators"
  curatorCount: Int!
  "Number of publishers"
  publisherCount: Int!
  "Number of TokenLockWallets"
  tokenLockWalletCount: Int!
}

type GraphAccount @entity {
  "ETH address of Graph Account"
  id: ID!
  "BadgeUser associated with this Graph Account"
  emblemUser: EmblemUser!
  "Number of Graph badges awarded to this account"
  awardCount: Int!
  "Indexer fields for this Graph Account. Null if never indexed"
  indexer: Indexer @derivedFrom(field: "account")
  "Delegator fields for this Graph Account. Null if never delegated"
  delegator: Delegator @derivedFrom(field: "account")
  "Curator fields for this Graph Account. Null if never curated"
  curator: Curator @derivedFrom(field: "account")
  "Developer fields for this Graph Account. Null if never published subgraphs"
  publisher: Publisher @derivedFrom(field: "account")
  "Token Lock Wallet for this Graph Account. Null if no token lock wallet"
  tokenLockWallets: [TokenLockWallet!] @derivedFrom(field: "beneficiary")
}

type TokenLockWallet @entity {
  "Contract address"
  id: ID!
  "Beneficiary of this TokenLockWallet"
  beneficiary: GraphAccount!
}

"""
Metadata for the Indexer along with parameters and staking data
"""
type Indexer @entity {
  "Address of Indexer"
  id: ID!
  "Graph Account associated with this indexer"
  account: GraphAccount!
  "Number of different subgraphs this indexer has allocated on"
  uniqueSubgraphAllocationCount: Int!
  "Number of currently open allocations"
  uniqueOpenAllocationCount: Int!
  "Cumulative number of Allocations closed by this indexer"
  allocationsClosedOnTime: Int!
  "CURRENT tokens delegated to the indexer"
  delegatedTokens: BigInt!
  "The total amount of indexing rewards given to delegators"
  delegatorIndexingRewards: BigInt!
  "The percent of indexing rewards generated by the total stake that the Indexer keeps for itself. In parts per million"
  indexingRewardCut: Int!
  "Total query fees collected. Includes the portion given to delegators"
  queryFeesCollected: BigInt!
  "Allocations created by this indexer"
  allocations: [Allocation!]! @derivedFrom(field: "indexer")
}

"""
A state channel Allocation representing a single Indexer-Subgraph stake
"""
type Allocation @entity {
  "Channel Address"
  id: ID!
  "Epoch this allocation was created"
  createdAtEpoch: BigInt!
  "Epoch this allocation was closed in"
  closedAtEpoch: BigInt
  "Indexer that created this allocation"
  indexer: Indexer!
  "Subgraph Deployment for this allocation"
  subgraph: SubgraphDeployment!
}

"""
Tracks which subgraphs an indexer has opened allocations on
"""
type SubgraphAllocation @entity {
  "{indexer}-{subgraphDeploymentId}"
  id: ID!
  "indexer indexing the subgraph"
  indexer: Indexer!
  "subgraph being indexed"
  subgraph: Subgraph!
}

"""
Metadata for the Delegator
"""
type Delegator @entity {
  "Address of Delegator"
  id: ID!
  "Graph Account associated with this delegator"
  account: GraphAccount!
  "Number of active delegations with at least 10k GRT"
  uniqueActiveDelegationCount: Int!
}

"""
Metadata for the Delegator
"""
type DelegatedStake @entity {
  "Delegator + Indexer"
  id: ID!
  "Delegator or this stake"
  delegator: Delegator!
  "Indexer that was delegated to"
  indexer: Indexer!
  "cumulative tokens delegated (does not account for undelegating)"
  tokens: BigInt!
  "true if tokens has ever been >= 100"
  crossed100: Boolean!
}

"""
Metadata for the Curator
"""
type Curator @entity {
  "Address of Curator"
  id: ID!
  "Graph Account associated with this curator"
  account: GraphAccount!
  "Number of different subgraphs Curator has signalled (cumulative)"
  uniqueSignalCount: Int!
}

"""
Metadata for the Curator
"""
type NameSignal @entity {
  "{Curator}-{SubgraphId}"
  id: ID!
  "Curator who signalled"
  curator: Curator!
  "Subgraph that was signalled on"
  subgraphId: Subgraph!
  "CUMULATIVE number of tokens the curator has signalled"
  signalledTokens: BigInt!
  "CUMULATIVE number of tokens the curator has unsignalled"
  unsignalledTokens: BigInt!
  "Shares of the name pool (GNS) that the curator has from signaling their GRT"
  nameSignal: BigInt!
  "Actual signal shares that the name pool minted with the GRT provided by the curator"
  signal: BigDecimal!
  "Curator average cost basis for this name signal on this subgraph"
  nameSignalAverageCostBasis: BigDecimal! # note this is ONLY name signal. This is okay for the protocol for now
  "nameSignalAverageCostBasis / nameSignal"
  nameSignalAverageCostBasisPerSignal: BigDecimal!
  "Curator average cost basis for the version signal on this subgraph name pool"
  signalAverageCostBasis: BigDecimal!
  "signalAverageCostBasis / signal"
  signalAverageCostBasisPerSignal: BigDecimal!
}

type Publisher @entity {
  "ETH address of Publisher Account"
  id: ID!
  "Graph Account associated with this publisher"
  account: GraphAccount!
  "Subgraphs published by this account"
  subgraphs: [Subgraph!]! @derivedFrom(field: "owner")
  "Number of Subgraphs this Publisher has deployed"
  subgraphCount: Int!
}

type Subgraph @entity {
  "{publisher}-{subgraph number}"
  id: ID!
  "Graph Account that published this subgraph"
  owner: Publisher!
  "First indexer to close an allocation on this subgraph"
  firstToOpen: Indexer
  "block which this subgraph was published (ignores versioning)"
  blockPublished: BigInt!
  "NameSignals associated with this Subgraph"
  nameSignals: [NameSignal!]! @derivedFrom(field: "subgraphId")
  "Subgraph metadata"
  metadataHash: Bytes!
  "Current version. Null if the subgraph is deprecated"
  currentVersion: SubgraphVersion
  "List of all the subgraph versions included the current one"
  versions: [SubgraphVersion!]! @derivedFrom(field: "subgraph")
  "Version counter"
  versionCount: BigInt!
}

"""
The SubgraphVersion entity represents a version of the Subgraph. A new SubgraphVersion is created
whenever there is an update to the Subgraph triggered by the owner. The new SubgraphVersion can
then point to a new SubgraphDeployment, thus allowing the Subgraph to resolve to a different
deployment, while keeping the same endpoint. The metadata and label are stored on IPFS. The label
is for the developer to provide a semantic version. This is different from the version, which is
just a counter than increases each time a new SubgraphVersion is created for a Subgraph.
"""
type SubgraphVersion @entity {
  "Concatenation of subgraph, subgraph deployment, and version ID"
  id: ID!
  "Subgraph of this version"
  subgraph: Subgraph!
  "Subgraph deployment of this version"
  subgraphDeployment: SubgraphDeployment!
  "Version number"
  version: BigInt!
  "Subgraph version metadata content address"
  metadataHash: Bytes!
}

"""
The SubgraphDeployment is represented by the immutable subgraph code that is uploaded, and posted
to IPFS. A SubgraphDeployment has a manifest which gives the instructions to the Graph Network on
what to index. The entity stores relevant data for the SubgraphDeployment on how much it is being
staked on and signaled on in the contracts, as well as how it is performing in query fees. It is
related to a SubgraphVersion.
"""
type SubgraphDeployment @entity {
  "Subgraph Deployment ID. The IPFS hash with Qm removed to fit into 32 bytes"
  id: ID!
  "Block when the subgraph was created"
  blockPublished: BigInt!
  "The versions this subgraph deployment relates to"
  versions: [SubgraphVersion!]! @derivedFrom(field: "subgraphDeployment")
}

"""
Protocols indexed by this subgraph
"""
type Protocol @entity {
  "Name of the protocol"
  id: ID!
}

########################
#### Badge Entities ####
########################

"""
Ethereum accounts this subgraph is tracking in order to award badges
"""
type EmblemUser @entity {
  "Ethereum address"
  id: ID!
  "Graph Account associated with this user"
  graphAccount: GraphAccount! @derivedFrom(field: "emblemUser")
  "Badges awarded to address"
  earnedBadges: [EarnedBadge!]! @derivedFrom(field: "emblemUser")
  "Progress being tracked along each BadgeMetric"
  liveData: [EmblemUserLiveData!]! @derivedFrom(field: "emblemUser")

  "Community score awarded when EmblemUsers complete badgeworthy on-chain activity"
  communityScore: BigInt!

  "Number of badge awards won"
  earnedBadgeCount: Int!
  "block number when live data was last posted on-chain"
  lastSyncedBlockNumber: BigInt!
}

"""
Orders EmblemUsers for merkle bridge compatibility (syncing live data)
"""
type EmblemUserCount @entity {
  "incrementing number"
  id: ID!
  "Int representation of id"
  userId: Int!
  "assiciated EmblemUser"
  emblemUser: EmblemUser!
}

type EmblemUserLiveData @entity {
  "{EmblemUser}-{BadgeMetric}"
  id: ID!
  "EmblemUser making progress"
  emblemUser: EmblemUser!
  "BadgeMetric being tracked"
  metric: BadgeMetric!
  "Current value of metric"
  value: BigInt!
  "Value that was last posted on-chain in a valid merkle root"
  valueOnChain: BigInt!
  "Maximum value acheived by EmblemUser"
  maxValue: BigInt!
  "Block number when EmblemUser achieved maxValue"
  maxValueBlockNumber: BigInt!
}

type MerkleRoot @entity {
  "root"
  id: ID!
  "starting index of leaves"
  startingIndex: Int!
  "number of leaves in the merkle tree"
  treeSize: Int!
  "true if leaves are liveData rather than earnedBadges"
  isLiveData: Boolean!
  "true if leaves hashed to root"
  isVerified: Boolean!
  "oracle that posted the root"
  emblemOracle: EmblemOracle
}

type EmblemOracle @entity {
  "address"
  id: ID!
  "merkle roots posted"
  rootsPosted: [MerkleRoot!]! @derivedFrom(field: "emblemOracle")
  "percentage of posted merkle roots that pass subgraph verification"
  performanceRating: Int!
}

"""
EarnedBadges are awarded to EmblemUsers for satisfying BadgeDefinition thresholds. EarnedBadge 
ids are an incrementing number, which facilitates future merkle proof verification via the Subgraph 
Bridge. This creates a streamlined interface for smart contracts to emit events with a merkle root 
and sorted range of leaves (in our case EarnedBadgeCounts) used to generate the root. With this data 
the subgraph verifies that the leaves hash to the root, effectively verifying an arbitrarily sized 
batch of data posted by an oracle.
"""
type EarnedBadge @entity {
  "incrementing number"
  id: ID!
  "Address of the EmblemUser"
  emblemUser: EmblemUser!
  "Block number in which badge was awarded"
  blockAwarded: BigInt!
  "Timestamp in which badge was awarded"
  timestampAwarded: BigInt!
  "Hash of the transaction that triggered this award"
  transactionHash: String!
  "Additional details about the badge"
  definition: BadgeDefinition!
  "Ordered number in which the badge was awarded for the associated definition"
  awardNumber: Int!
  "Data specific to earnedBadges of a given BadgeDefinition"
  metadata: [EarnedBadgeMetadata!]! @derivedFrom(field: "earnedBadge")
}


type BadgeMetric @entity {
  id: ID!
  metricNumber: Int!
  metricName: String!
  protocolRole: ProtocolRole!
}

"""
BadgeDefinitions are created by the BadgeDefinitionManager smart contract.
Subgraphs may also have genesis BadgeDefinitions that are baked in for retroactive
drops.
"""
type BadgeDefinition @entity {
  "incrementing number"
  id: ID!
  "Name of badge"
  name: String!
  "Description of badge"
  description: String!
  "IPFS URI containing metadata about this BadgeDefinition"
  ipfsURI: String!
  "Metric being tracked"
  metric: BadgeMetric!
  "Value that metric must reach in order for a badge to be awarded"
  threshold: BigInt!
  "Community score given when badge is awarded"
  communityScore: BigInt!
  "Total count of earned badges"
  earnedBadgeCount: Int!
  "Badges awarded with this definition"
  earnedBadges: [EarnedBadge!]! @derivedFrom(field: "definition")
}

"""
Tracks EmblemUser's protocol roles and role-specific community score
"""
type EmblemUserRole @entity {
  "{EmblemUser}-{ProtocolRole}"
  id: ID!
  "Associated EmblemUser"
  emblemUser: EmblemUser!
  "Associated Protocol Role"
  protocolRole: ProtocolRole!
  "Accumulated community score for badges with this protocol role"
  communityScore: BigInt!
}

enum ProtocolRole {
  INDEXER
  DELEGATOR
  CURATOR
  SUBGRAPH_DEVELOPER
  CONSUMER
  FISHERMAN
  EMBLEM_USER
}

################################
#### Internal Badge Entities ###
################################

"""
Singleton entity that tracks numbers and stats relating to Emblem
"""
type EmblemEntityStats @entity {
  "ID is set to 1"
  id: ID!
  "Number of badges earned"
  earnedBadgeCount: Int!
  "Number of unique BadgeWinners"
  emblemUserCount: Int!
  "Number of unique BadgeDefinitions created (including Genesis badges)"
  badgeDefinitionCount: Int!
  "Number of BadgeMetric entities"
  badgeMetricCount: Int!
}

################################
# These are only required by Emblem frontend
################################

enum EarnedBadgeMetadataName {
  INDEXER
  DELEGATOR
  CURATOR
  SUBGRAPH_DEVELOPER
  SUBGRAPH
  SUBGRAPH_DEPLOYMENT
  TOKENS
}

"""
EarnedBadge metadata specific to the given BadgeDefinition
"""
type EarnedBadgeMetadata @entity {
  "{EarnedBadge}-{metricName}"
  id: ID!
  "Name of metric"
  name: EarnedBadgeMetadataName!
  "Value"
  value: String!
  "EarnedBadge the metadata refers to"
  earnedBadge: EarnedBadge!
}

"""
BadgeMetric -> BadgeDefinitions tracking that metric
"""
type MetricConsumer @entity {
  "BadgeMetric"
  id: ID!
  "BadgeDefinitions using this metric"
  badgeDefinitions: [BadgeDefinition!]!
}
